#!/usr/bin/perl -w

#
# LARD - based on code from syslog-snarf.pl - by
#
# The author disclaims all copyrights and releases this document into
# the public domain.
#
# Lard is a syslogd-like loggin daemon that can rotate logfiles,
# trigger commands on specific messages and perform regex matching.
#
# see `man lard` and `man lard.conf` for more information, or
# issue `lard -h`.
#

use strict;

use Socket;
use IO::Socket;
use IO::Select;

use Sys::Syslog;
use Net::Syslog;

use Sys::Hostname;

use Getopt::Std;
use Date::Parse;
use POSIX qw(strftime);

# what address to listen on (default everywhere)
my $bind;

# what port to bind to by default
my $port = 514;

my $stampfile = "/var/state/lard";
# max message length for incoming data ([RFC 3164] limits this to 1024
# by default, though things might not follow the standards)
my $max_msg_len	= 5000;
my $msg_len_warn = 1024;

use vars qw(@rules %option %opts $PRI_data_re $HEADER_MSG_re_syslog_ng);


# to match PRI header plus remaining fields
my $PRI_data_re = qr/^ < (\d{1,3}) > (.*) /x;

# to decode remaining data past the priority into TIMESTAMP, HOSTNAME,
# and MSG fields
my $HEADER_MSG_re_syslog_ng = qr/^ ((	# match HEADER, TIMESTAMP for reference
	(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)	# Month
	(?:[ ][ ]\d|[ ]\d\d) # day of month, '	5' or ' 10'
	[ ] \d\d:\d\d:\d\d)  # timestamp
	[ ] ([\w@.:-]+)      # HOSTNAME host|IPv4|IPv6 (syslog-ng prefixes foo@?)
	)                    # close match on HEADER
	[ ] (.*)             # MSG data
/x;
my $HEADER_MSG_re_solaris = qr/^ ((
	(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)	# Month
	(?:[ ][ ]\d|[ ]\d\d) # day of month, '	5' or ' 10'
	[ ] \d\d:\d\d:\d\d)  # timestamp
	)                    # close match on HEADER
	[ ] (.*)             # MSG data
/x;

# see strftime man page for allowed fields here
my $timestamp_template = "%Y-%m-%d %H:%M:%S%z";

# this is a custom template based on contents of %message hash for each
# log entry
my $message_template =
 '%{TIMESTAMP} <%{facility}.%{priority}> %{HOSTNAME} %{MSG}\n';

# syslog.h code->name mappings for better output
my %syslog_priorities = (
	0 => 'emerg',
	1 => 'alert',
	2 => 'crit',
	3 => 'err',
	4 => 'warn',
	5 => 'notice',
	6 => 'info',
	7 => 'debug'
);
my $pri_mask_full = ((2<<8) - 2);

# TODO some vendors (notably Apple) have fiddled with these to add
# NETINFO and similar... support this by reading these defintions
# from a file?
my %syslog_facilities = (
	0  => 'kern',
	1  => 'user',
	2  => 'mail',
	3  => 'daemon',
	4  => 'auth',
	5  => 'syslog',
	6  => 'lpr',
	7  => 'news',
	8  => 'uucp',
	9  => 'cron',
	10 => 'authpriv',
	11 => 'ftp',
	16 => 'local0',
	17 => 'local1',
	18 => 'local2',
	19 => 'local3',
	20 => 'local4',
	21 => 'local5',
	22 => 'local6',
	23 => 'local7'
);

my $fac_mask_full = ((2<<24) - 2);

my %syslog_facilities_rv;
my %syslog_priorities_rv;
# generate reverse hashes for speedy lookups
for my $key (keys %syslog_facilities) {
	$syslog_facilities_rv{$syslog_facilities{$key}} = $key;
}
for my $key (keys %syslog_priorities) {
	$syslog_priorities_rv{$syslog_priorities{$key}} = $key;
}

# format our $id
my $id = $0;
$id =~ s/.*\///;

my $VERSION = "0.1.2";

# parse command-line options
getopts 'h?rnsf:v', \%opts;

print_help() if exists $opts{'h'} or exists $opts{'?'};

print "$VERSION\n" and exit if exists $opts{'v'};

&parse_config();

#for my $rule (@rules) {
#	for my $key (keys %{$rule}) {
#		print "$key => ${$rule}{$key}\n";
#	}
#	print "\n";
#}

# start up the syslog server
my $pidfile = "/var/run/$id.pid";
local *PID;
if (! exists $opts{'s'}) {
	# normal daemon startup
	if (-e "$pidfile") {
		die "error: another instance of $id is running";
	}
	open (PID, ">$pidfile");
	print PID $$;
	close (PID);
} else {
	# send a rotate signal and quit
	open (PID, "$pidfile") or die "error: could not find pid";
	my $daemon;
	$daemon = (<PID>);
	close (PID);
	kill ( 10, $daemon) or die "error: could not send signal USR1 to process $daemon";
	exit 0;
}


# listen on the UDP socket
my $sock1;
my $sock2;
if ($opts{'r'}) {
	# check for remote reception listen address
	my @bind;
	if ($option{'listen'}) {
		(@bind) = ('LocalAddr', (split(/:/, $option{'listen'}))[0]);
		for ($option{'listen'}) {
			/:/ && do {
				$port = ((split(/:/, $option{'listen'}))[1])
			};
		}
	}

	$sock1 = IO::Socket::INET->new(
		Proto     => 'udp',
		LocalPort => $port,
		@bind
	  )
	  or die "error: could not start server: errno=$@\n";
}

# listen on socket
my $socketfile;
if ($option{'socket'}) {
	$socketfile = $option{'socket'};
} else {
	$socketfile = '/dev/log';
}
if (-e $socketfile) {
	unlink $socketfile or die "error: cannot get socket \"$socketfile\"";
}
$sock2 = IO::Socket::UNIX->new(
	Local   => "$socketfile",
	Type    => SOCK_DGRAM,
	Listen  => 0
 )
 or die "error: could not start server: errno=$@\n";
chmod 0666, "$socketfile";

$| = 1;												# autoflush output

#nonblock($sock1);
#nonblock($sock2);

my $select = IO::Select->new();
if ($opts{'r'}) {
	$select->add($sock1);
}
$select->add($sock2);

# and add the signal hook:
$SIG{'USR1'} = \&catch_rotate_signal;
$SIG{'TERM'} = \&end;
$SIG{'INT'} = \&end;
$SIG{'HUP'} = \&end;

# fork into the background unless we don't want that
my $pid;
($opts{'n'}) or ($pid = fork and exit);

$id .= "\[$$\]";

# send out a syslog.notice that we have just started
send_local ('notice', "$id: started");

while(1) {
	# handle messages as usual
	while (my @ready = $select->can_read) {
		foreach my $sock (@ready) {
			read_message_from_socket ($sock);
		}
	}
}

# add signal handler to trigger rotation
sub catch_rotate_signal {
	send_local ('notice', "$id: Received rotation request signal (USR1)");
	rotate_all();
}

sub end {
	# send out a syslog.notice that we are exiting, but only for
	($pid) or send_local ( 'notice', "$id: Shuting down");
	unlink ("$pidfile") if not exists $opts{'s'};
	$sock1->close if $sock1;
	$sock2->close if $sock2;
	exit 0;
}

END {
	if ($pidfile) {
		unlink ("$pidfile") if not exists $opts{'s'};
	}
	$sock1->close if $sock1;
	$sock2->close if $sock2;
}

sub send_local {
	# send a message to ourselves locally, so it can be parsed and passed
	# through our ruleset
	my $pri = shift;
	my $pri_code = $syslog_priorities_rv{$pri};
	write_message({
		'facility' => 'syslog',
		'facility_code' => '5',
		'priority' => $pri,
		'priority_code' => $pri_code,
		'MSG' => shift,
		'TIME' => time,
		'HOSTNAME' => hostname()
	  });
}


sub send_remote {
	# send a message to a specific loghost
	my $host = shift;
	my %message = %{ shift() };

	my $syslog = new Net::Syslog (
			SyslogHost => $host,
			Facility => $message{'facility'},
			Priority => $message{'priority'}
		);
	$syslog->send("$message{'MSG'}\n");
}


sub unquote {
	# remove "" quotes from a string
	my $word = shift;
	$word =~ s/^"(.*)"$/$1/;
	return $word;
}


sub format_message {
	my $template = shift;
	my %message = %{ shift() };
	
	# converts '\n' and similar to actual character
	( my $output = $template ) =~ s/(\\.)/qq!"$1"!/eeg;

	# replaces %{foo} keys from %message hash with values for log entry
	$output =~ s/%{(\w+)}/$message{$1}||''/eg;
	return $output;
}


sub parse_config {
	my @words;

	# read and parse rules from the config file
	local *CONF;
	my $conf = "/etc/lard.conf";
	$conf = $opts{'f'} if exists $opts{'f'};
	open(CONF, "$conf") or die "error: cannot open configuration file \"$opts{'f'}\"";
	while (<CONF>) {
		s/#.*$//g;
		for (m/(\x22[^\x22]+\x22|\x27[^\x27]+\x27|\x60[^\x60]+\x60|[0-9a-zA-Z\x21\x23-\x26\x2a-\x3a\x3c-\x7a\x7c\x7e\x7f]+|\x28|\x29|\x7b|\x7d|\x3b)/g) {
			push @words, $_;
		}
	}
	close (CONF);

	my %rule;
	undef %rule;
	# while ($word = shift @words) {
	while ( local $_ = shift @words ) {
		/^(?:file|pipe|command|host)$/ && do {
			if (%rule) {
				# store last rule if it exists
				push @rules, {%rule};
				undef %rule;
			}
			# create a new rule
			$rule{$_} = unquote ( shift @words );
			next;
		};
		/^(?:socket|domain|listen|log|timeformat|format|keep|rotate|compress|match)$/ && do {
			if (! %rule) {
				$option{$_} = unquote ( shift @words );
			} else {
				# global options
				$rule{$_} = unquote ( shift @words );
				# create binary mask for facility.priority
				/^log$/ && do {
					# set the default mask to full
					my ( $fac, $pri ) = split ( /\./, $rule{$_} );
					# facility
					if ( $fac eq '*' ) {
						$rule{'fac_mask'} = $fac_mask_full;
					} else {
						for my $fac_item ( split ( /\,/, $fac ) ) {
							# if negated, deduct the prio from the mask
							if ( substr($fac_item, 0, 1) eq '!' ) {
								if (! $rule{'fac_mask'}) {
									$rule{'fac_mask'} = $fac_mask_full;
								}
								if (exists $syslog_facilities_rv{substr($fac_item, 1)}) {
									$rule{'fac_mask'} &= ( $fac_mask_full - ( 2<<$syslog_facilities_rv{substr($fac_item, 1)} ) );
								} else {
									die "error: illegal facility name \"$fac_item\"";
								}
							} else {
								# else add it to it
								if (exists $syslog_facilities_rv{$fac_item}) {
									$rule{'fac_mask'} |= ( 2<<$syslog_facilities_rv{$fac_item} );
								} else {
									die "error: illegal facility name \"$fac_item\"";
								}
							}
						}
					}
					# priority
					if ( $pri eq '*' ) {
						$rule{'pri_mask'} = $pri_mask_full;
					} else {
						for my $pri_item ( split ( /,/, $pri ) ) {
							# if negated, deduct the prio from the mask
							if ( substr($pri_item, 0, 1) eq '!' ) {
								if (! $rule{'pri_mask'} ) {
									$rule{'pri_mask'} = $pri_mask_full;
								}
								if (exists $syslog_priorities_rv{substr($pri_item, 1)}) {
									$rule{'pri_mask'} &= ( $pri_mask_full - ( 2<<$syslog_priorities_rv{substr($pri_item, 1)} ) );
								} else {
									die "error: illegal priority name \"$pri_item\"";
								}
							} else {
								# else add it to it
								if (exists $syslog_priorities_rv{$pri_item}) {
									$rule{'pri_mask'} |= ( 2<<$syslog_priorities_rv{$pri_item} );
								} else {
									die "error: illegal priority name \"$pri_item\"";
								}
							}
						}
					}
				}
			}
			next;
		}
	}

	# add the last rule in case it's there
	if (%rule) {
		push @rules, {%rule};
	}
}


sub get_timestamp {
	my $file = shift;
	local *STAMP;
	if (open (STAMP, $stampfile)) {
		while (<STAMP>) {
			/^$file .*$/ && do {
				$_ =~ s/$file //;
				chomp;
				close (STAMP);
				return $_;
			};
		}	
		close (STAMP);
		# fallback: record the time for a file missing a timestamp:
		write_timestamp($file);
		return time;
	} else {
		write_timestamp($file);
		return time;
	}
}


sub write_timestamp {
	my $file = shift;
	my @lines;
	local *STAMP;
	if (open (STAMP, "$stampfile")) {
		while (<STAMP>) {
			/^$file .*$/ || do {
				push @lines, $_;
			};
		}
		close (STAMP);
		open (STAMP, ">$stampfile");
		for my $line (@lines) {
			print STAMP "$line";
		}
		print STAMP "$file" . " " . time . "\n";
		close (STAMP);
	} else {
		open (STAMP, ">$stampfile") or die "error: cannot create timestamp file \"$stampfile\"";
		print STAMP "$file" . " " . time . "\n";
		close (STAMP);
	}
}


sub rotate_all {
	# check to see if we can rotate logfiles now
	my ($keep, $rotate, $compress);
	for my $rule (@rules) {
		if ((${$rule}{'file'}) && (-f ${$rule}{'file'}) && (${$rule}{'file'} ne "=")) {
			# it's a logfile rule -> recover the rotation params
			if (${$rule}{'keep'}) {
				$keep = ${$rule}{'keep'};
			} elsif ($option{'keep'}) {
				$keep = $option{'keep'};
			} else {
				$keep = 4;
			}
			if (${$rule}{'rotate'}) {
				$rotate = ${$rule}{'rotate'};
			} elsif ($option{'rotate'}) {
				$rotate = $option{'rotate'};
			} else {
				$rotate = "weekly";
			}
			if (${$rule}{'compress'}) {
				$compress = ${$rule}{'compress'};
			} elsif ($option{'compress'}) {
				$compress = $option{'compress'};
			} else {
				$compress = "none";
			}

			my $ctime = get_timestamp(${$rule}{'file'});
			for ($rotate) {
				/^(?:hourly|daily|weekly|monthly)$/ && do {
					if (
							(($rotate eq "hourly") && ($ctime < (time - 3600))) ||
							(($rotate eq "daily") && ($ctime < (time - 80640))) ||
							(($rotate eq "weekly") && ($ctime < (time - 564480))) ||
							(($rotate eq "monthly") && ($ctime < (time - 2452262))) ) {
						rotate_file (${$rule}{'file'}, $keep, $compress);
						write_timestamp(${$rule}{'file'});
					}
					next;
				};
				/^(?:\d+[KMG]|\d+)$/ && do {
					$rotate =~ s/K$/000/;
					$rotate =~ s/M$/000000/;
					$rotate =~ s/G$/000000000/;
					if (((stat(${$rule}{'file'}))[7]) >= $rotate) {
						rotate_file (${$rule}{'file'}, $keep, $compress);
					}
					next;
				};
			}
		}
	}
}

sub rotate_file {
	# takes a filename as argument #1
	# numer of rotations as #2
	# compression method as #3
	my $file = shift;
	my $keep = shift;
	my $compress = shift;

	send_local ('debug', "$id: Rotating $file");

	my $suffix;
	if ($compress eq "bzip2") {
		$suffix = ".bz2";
	} elsif ($compress eq "gzip") {
		$suffix = ".gz";
	}

	for ( my $num = $keep; $num > 0 ; $num-- ) {
		# move old files up
		if ( -f "$file." . $num . "$suffix" ) {
			if ($num == $keep) {
				# delete the oldes if it's the last one to keep
				unlink "$file." . $num . "$suffix";
			} else {
				# move them up
				rename "$file." . $num . "$suffix", "$file." . ($num+1) . "$suffix";
			}
		}
	}
	# now move the current one
	if ( -f "$file" ) {
		rename "$file", "$file.1";
		# and compress it
		if (( $compress ne "none" ) && (fork == 0)) {
			exec("$compress $file.1");
		}
	}
}

# this is the incoming message handler
sub read_message_from_socket {
	my $sock = shift;
	my ( %message, @errors );
	
	%message = ();
	@errors	= ();

	$sock->recv( $message{'raw'}, $max_msg_len );

	$message{'time_recv'} = time;
	
	# distonguish based on the protocol
	if ( $sock->sockdomain == AF_INET ) {
		# get various info on the packet in question
		$message{'peerhost'} = gethostbyaddr( $sock->peeraddr, AF_INET )
		 || $sock->peerhost;
		$message{'peerport'} = $sock->peerport;
	} else {
		# log with local name
		$message{'peerhost'} = hostname();
	}

	# see [RFC 3164] for syslog message format details
	$message{'length'} = length( $message{'raw'} );
	push @errors, "message exceeds length of $msg_len_warn"
	 if $message{'length'} > $msg_len_warn;

	if ( $message{'length'} == 0 ) {
		push @errors, 'message contains no data';
		next;
	}

	my $header_msg = '';

	if ( $message{'raw'} =~ m/$PRI_data_re/o ) {
		( $message{'PRI'}, $header_msg ) = ( $1, $2 );

		# decode facility/priority (see [RFC 2234] for PRI part values
		if ( $message{'PRI'} ) {
			$message{'priority_code'} = $message{'PRI'} % 8;
			if ( exists $syslog_priorities{ $message{'priority_code'} } ) {
				$message{'priority'} = $message{'priority_code'};
				$message{'priority'} = $syslog_priorities{ $message{'priority_code'} };
			} else {
				push @errors, "no name for priority $message{'priority_code'}";
			}

			$message{'facility_code'} = int( $message{'PRI'} / 8 );
			if ( exists $syslog_facilities{ $message{'facility_code'} } ) {
				$message{'facility'} = $syslog_facilities{ $message{'facility_code'} };
			} else {
				$message{'facility'} = $message{'facility_code'};
				push @errors, "no name for facility $message{'facility_code'}";
			}
		}

	} else {
		push @errors, 'could not parse PRI field';
		next;
	}

	# TODO is syslog-ng adding \n to the data already?
	chomp $header_msg;
	if ( $header_msg =~ m/$HEADER_MSG_re_solaris/o ) {
		(
		 $message{'HEADER'},	 $message{'TIME'},
		 $message{'HOSTNAME'}, $message{'MSG'}
		)
		 = ( $1, str2time ($2), $message{'peerhost'}, $3 );
		# solaris' syslogd passes the fac.pri tuple, get rid if it:
		$message{'MSG'} =~ s/ $message{'facility'}\.$message{'priority'}// ;
	} elsif ( $header_msg =~ m/$HEADER_MSG_re_syslog_ng/o ) {
		(
			$message{'HEADER'},	 $message{'TIME'},
			$message{'HOSTNAME'}, $message{'MSG'}
		)
		 = ( $1, str2time ($2), $3, $4 );
	} else {
		(
		 $message{'HEADER'},	 $message{'TIME'},
		 $message{'HOSTNAME'}, $message{'MSG'}
		)
		 = ( '', time , $message{'peerhost'}, $header_msg );
	}

	if ( $opts{'v'} and @errors ) {
		warn "error: $_\n" for @errors;
	}

	write_message(\%message);
}

sub write_message {
	# write a message hash to the appropriate logfiles
	my %message = %{ shift() };

	# here we traverse our logging rules and apply the proper procedure
	# (multiple actions possible)
	for my $rule (@rules) {
		# do not attempt to match rules that are for rotation-only files:
		(${$rule}{'log'}) or next;
		# perform a match on $message{'facility|priority'}
		if ( ( ${$rule}{'pri_mask'} & ( 2<<$message{'priority_code'}) ) &&
				( ${$rule}{'fac_mask'} & ( 2<<$message{'facility_code'}) ) ) {
			# strip the hostname down if requested:
			if (${$rule}{'domain'}) {
				$message{'HOSTNAME'} =~ s/\.${$rule}{'domain'}//;
			} elsif (exists $option{'domain'}) {
				$message{'HOSTNAME'} =~ s/\.$option{'domain'}//;
			}
			# create the output format message now
			my $output;
			# figure out what timestamp format we need
			if ( defined ${$rule}{'timeformat'} ) {
				$message{'TIMESTAMP'} = strftime ${$rule}{'timeformat'}, localtime ($message{'TIME'});
			} elsif ( defined $option{'timeformat'} ) {
				$message{'TIMESTAMP'} = strftime $option{'timeformat'}, localtime ($message{'TIME'});
			} else {
				$message{'TIMESTAMP'} = strftime $timestamp_template, localtime ($message{'TIME'});
			}
			if ( defined ${$rule}{'format'} ) {
				$output = format_message ( ${$rule}{'format'}, \%message );
			} elsif ( defined $option{'format'} ) {
				$output = format_message ( $option{'format'}, \%message );
			} else {
				$output = format_message ( $message_template, \%message );
			}
			# complex match so we can match hostname/time too:
			for ($output) {
				# seach for a pattern if applicable
				if ( (! defined ${$rule}{'match'} ) || 
						( m/${$rule}{'match'}/ ) ) {
					if (defined ${$rule}{'file'}) {
						# append the message to this file
						if ( ${$rule}{'file'} eq "-" ) {
							print $output;
						} else {
							# very bad writing below
							local *LOG;
							open ( LOG, ">>${$rule}{'file'}" ) or die "error: cannot open \"${$rule}{'file'}\" for writing";
							print LOG $output;
							close ( LOG );
						}
					} elsif (defined ${$rule}{'pipe'}) {
						# write to a pipe

					} elsif (defined ${$rule}{'command'}) {
						# execute a command
						chomp $output;
						if (fork == 0) {
							# $SIG{CHLD} = 'IGN' || waitpid(-1, WNOHANG)
							exec("${$rule}{'command'} \'$output\'");
						}
					} elsif (defined ${$rule}{'host'}) {
						# log to a remote host
						send_remote ( ${$rule}{'host'}, \%message );
					}
				}
			}
		}
	}
}


sub print_help {
	# a generic help blarb
	print <<HELP;
Usage: $id [opts]

Logging and rotation daemon 

Options for lard:
    -h/-?    Display this message

    -r       Enable remote reception of syslog messages
    -n       Do not daemonize: stay in the foreground
    -s       Send a running lard daemon a rotate signal. If no
             running instance is found, rotate files and exit
    -f conf  Specify an alternative configuration file

See lard(8) and lard.conf(5) for additional documentation

HELP
	exit 100;
}

=head1 NAME

LARD - Log and Rotate Daemon

=head1 SYNOPSIS

Run this daemon like you would any other. The daemon automatically
forks into the background after parsing the config file:

    # lard

Make sure there isn't a process already occupying the /dev/log
socket or the UDP port in case you listen to remote messages:

    # lard -r

=head1 DESCRIPTION

lard is a replacement for styslogd and logrotate in one. It makes 
a lot of sense to combine the ability of these two programs together
since the daemon can rotate the logfiles independently of write
access to logfiles because it knows best when it's writing to them.

lard has also better pattern matching and can match regular expressions
on the message part of log messages, next to the traditional facility
and priority matching.

The output formats of the messages is custom, and a lot of fields
can be chosen to display the type of message, header details and
date/time formats. Per logfile/command these options can be adjusted.

Rotation can be done based on time or size. Time rotation data
is kept in a separate file and thus on the first run may not be accurate.

Rotation is not automatically triggered. However, you must signal
a running lard instance that it is time to rotate the logfiles it
keeps track of. The signal for this is SIGURS1. You can also
call lart with the -s option to do this automatically, without
the need to lookup the PID (which is kept by default in
/var/run/lard.pid).

The daemon can run in the foreground and dump selected messages
to stdout if you create a 'log "-"' rule, where "-" is the alias
used for STDOUT. Any message matching the criteria will be
printed on stdout.

A message matching special criteria can also be passed directly to
a shell command. This can be usefull to send alerts directly, without
waiting for auditing tools to find them later. Beware that using
input from messages in scripts run as root could be a security
risk.

Remote reception and delivery is supported with a 'host "hostname"'
rule. Use the '-r' option to enable the UDP socket for incoming
syslog messages. Alternatively, you can provide a 'listen' address
to change the default (which is ALL available addresses) address
and port.

=head2 Normal Usage

	# lard [options]

See L<"OPTIONS"> for details on the command line switches supported.

=head1 OPTIONS

lard currently supports the following command line switches:

=over 4

=item B<-h>, B<-?>

Prints a brief usage note.

=item B<-r>

Enable remote reception. The daemon will open a UDP socket and listen
on port 514 by default.

=item B<-f> I<filename>

Open a different configuration file instead of the default, which is
/etc/lard.conf.

=item B<-n>

Do not daemonize. The daemon doesn't run in the background. Usefull
with the stdout logging possibility.

=item B<-s>

Send a rotate trigger to a running lard daemon. The lard daemon will
check if any file needs to be rotated according to the criteria in
the lard.conf file, and rotate the logfiles appropriate. The client
lard process will exit immediately. Alternatively, you can also
directly send a SIGUSR1 to the running lard daemon directly.

=back

=head1 BUGS

=head2 Reporting Bugs

See http://lard.foo-projects.org/ for contact information.

=head2 Known Issues

None at this moment.

=head1 SEE ALSO

lard(8), lard.conf(5), [RFC 3164]

=head1 AUTHOR

lard was written by Auke Kok, http://lard.foo-projects.org/

=head1 COPYRIGHT

The author disclaims all copyrights and releases this document into the
public domain.

=head1 HISTORY

Adapted from udp_echo_serv.pl by Lincoln D. Stein in the text
http://www.modperl.com/perl_networking/ (Chapter 18), plus data from
the Net::Syslog module as well as information in the sys/syslog.h
header file.

Parts used from syslog_snarf.pl, written by Jeremy Mates,
http://sial.org/contact/

=cut
